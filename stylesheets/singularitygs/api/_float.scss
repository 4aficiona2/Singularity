@function output-float($Span-Map) {
  // Set up Left/Right maps
  $Return: (
    'exclude': (
      'right': 'width'
    )
  );

  $Span: map-get($Span-Map, 'span');
  $Location: map-get($Span-Map, 'location');

  $Grid: map-get($Span-Map, 'grid');
  $Gutter: map-get($Span-Map, 'gutter');
  $Style: map-get($Span-Map, 'style');

  $Start-Row: map-get($Span-Map, 'start row');
  $End-Row: map-get($Span-Map, 'end row');

  $Fixed-Gutter: map-get($Span-Map, 'fixed gutter');
  $Split-Gutter: map-get($Span-Map, 'split gutter');
  $Gutter-Property: map-get($Span-Map, 'gutter property');

  $Options: map-get($Span-Map, 'options');

  @if $Start-Row {
    $Location: 1;
  }
  @else if $End-Row {
    $Location: column-count($Grid) - $Span;
  }

  $Width: column-span($Span, $Location, $Grid, $Gutter, $Style);
  $Margin-Span: column-span(($Location - 1), 1, $Grid, $Gutter, $Style);
  $Gutter-Span: gutter-span($Gutter, $Grid);

  // Backwards Compatibility for Options
  @if type-of($Options) != 'map' and $Options != null {
    $Options: ('clear': unquote(nth($Options, 1)));
  }

  $directions: 'ltr' 'rtl';

  @each $direction in $directions {
    // Set up direction and holder
    $Holder: ();
    $CSSDir: $direction;
    // Find the CSS named direction and opposite direction

    $Dir: named-direction($CSSDir);
    $Opp: opposite-direction($Dir);

    $Holder: map-merge($Holder, ('width': $Width));
    $Holder: map-merge($Holder, ('clear': $Opp));

    @if ($End-Row) {
      $Holder: map-merge($Holder, ('float': $Opp));

      @if $Split-Gutter and not $Fixed-Gutter {
        $Holder: map-merge($Holder, ('#{$Gutter-Property}-#{$Dir}': 0));
        $Holder: map-merge($Holder, ('#{$Gutter-Property}-#{$Opp}': $Gutter-Span / 2));
      }
      @else if not $Fixed-Gutter {
        $Holder: map-merge($Holder, ('#{$Gutter-Property}-#{$Opp}': 0));
      }
    }
    @else {
      $Holder: map-merge($Holder, ('float': $Dir));

      @if $Split-Gutter and not $Fixed-Gutter {
        $Holder: map-merge($Holder, ('#{$Gutter-Property}-#{$Dir}': $Gutter-Span / 2));
        $Holder: map-merge($Holder, ('#{$Gutter-Property}-#{$Opp}': $Gutter-Span / 2));
      }
      @else if not $Fixed-Gutter {
        @if $Start-Row {
          $Holder: map-merge($Holder, ('#{$Gutter-Property}-#{$Dir}': 0));
        }
        $Holder: map-merge($Holder, ('#{$Gutter-Property}-#{$Opp}': $Gutter-Span));
      }
    }
    // If options are set, we merge them in!
    @if ($Options) {
      $Holder: map-merge($Holder, $Options);
    }

    // If CLear isn't already available, set it!
    @if not map-has-key($Holder, 'clear') {
      $Holder: map-merge($Holder, ('clear': none));
    }

    // Left Fixed Gutters
    @if $Fixed-Gutter {
      @if index($Style, 'split') {
        $Holder: map-merge($Holder, ('#{$Gutter-Property}-#{$Dir}': $Gutter-Span / 2));
        $Holder: map-merge($Holder, ('#{$Gutter-Property}-#{$Opp}': $Gutter-Span / 2));
      }
      @else {
        @if not $End-Row {
          $Holder: map-merge($Holder, ('#{$Gutter-Property}-#{$Opp}': $Gutter-Span));
        }
        @else {
          $Holder: map-merge($Holder, ('#{$Gutter-Property}-#{$Opp}': 0));
        }
      }
    }

    $Return: map-merge($Return, ('#{$Dir}': $Holder));
  }

  @return $Return;
}

//////////////////////////////
// Happy Syntax for Float
//
// Makes working with Float easier, as it allows you to walk the grid for symmetric grids and easy applying of 'last' and 'first', as well as automatically building the verbose grid-span mixin call
//////////////////////////////
@mixin float-span($Span, $Location: false, $grid: false, $gutter: false) {
  $grid: find-grid($grid);
  $gutter: find-gutter($gutter);
  $row: false;

  // Working around SASS treating a number like a list with one element
  @if type-of($grid) == 'list' and length($grid) == 1 {
    $grid: nth($grid, 1);
  }

  // Working with a symmetric grid
  @if type-of($grid) == 'number' {
    // Special treatment for non-numeric location
    @if type-of($Location) != 'number' {
      @if $Location == 'last' or $Location == 'omega' {
        $Location: $grid - $Span + 1;
      }
      @else {
        @if $Location == 'first' or $Location == 'alpha' {
          $row: true;
        }
        $Location: 1;
      }
    }

    @include grid-span($Span, $Location, $grid, $gutter, 'float');

    @if $row {
      clear: both;
    }
  }
  // Working with an asymmetric grid, should have location provided
  @else if type-of($grid) == 'list' and $Location != false {
    @include grid-span($Span, $Location, $grid, $gutter, 'float');
  }
  @else {
    @warn 'Asymmetric Grids need a Location value as well as a span value in order to know where on the grid you are! Please include a location value!';
  }
}
